---
import type { HTMLAttributes } from 'astro/types';
interface Props extends HTMLAttributes<'a'> {
	primary?: boolean;
	secondary?: boolean;
	/** Remove underline text decoration.  */
	'no-underline'?: boolean;
	'hover-underline'?: boolean;
	badge?: boolean;
	/** Make the link appear as a success badge. */
	'badge-success'?: boolean;
	/**
	 * Load the link before navigating.
	 */
	prefetch?: boolean;
	/**
	 * Only load the link when hovered or focused.
	 */
	'prefetch-intent'?: boolean;
}

const {
	href = '#',
	target = '_blank',
	rel,
	class: className,
	primary,
	secondary,
	'no-underline': noUnderline,
	'hover-underline': hoverUnderline,
	badge,
	'badge-success': badgeSuccess,
	prefetch: prefetch,
	'prefetch-intent': prefetchIntent,
	...attrs
} = Astro.props;

const _rel = createRel(rel, prefetch, prefetchIntent);

type ClassObj = Record<string, string | null | undefined | boolean>;
type Classes = (string | ClassObj)[];

const classes = [
	'link',
	{
		'link-primary': primary,
		'link-hover': hoverUnderline,
		'link-secondary': secondary,
		badge: badge || badgeSuccess,
		'badge-success': badgeSuccess,
		// TODO refactor adding className;
		// removeLinkKeys() has extra logic to remove the empty string which is leaky
		[className ?? '']: className,
	},
].reduce<Classes>((accum, curr) => {
	if (!noUnderline) {
		// keep classes as is
		accum.push(curr);
		return accum;
	}
	if (typeof curr == 'string' && !isLinkClass(curr)) accum.push(curr);
	else if (typeof curr == 'object') accum.push(removeLinkKeys(curr));
	return accum;
}, []);
/** Create a new object with link keys removed. */
function removeLinkKeys(clsObj: ClassObj): ClassObj {
	return Object.entries(clsObj).reduce<ClassObj>((accum, curr) => {
		const [key, val] = curr;
		const keyIsLinkClass = isLinkClass(key);

		if (!keyIsLinkClass && key !== '') accum[key] = val;
		return accum;
	}, {});
}

/** Check if a class string is prefixed with `'link'`. */
function isLinkClass(clsStr: string): boolean {
	const linkClsPrefix = 'link';
	return clsStr.startsWith(linkClsPrefix);
}
function createRel(
	rel?: string | null | undefined,
	prefetch?: boolean,
	prefetchIntent?: boolean,
): string {
	const defaultRel = 'noreferrer';

	if (!rel || rel.trim() === '') rel = defaultRel;
	rel = rel.trim();

	return [
		rel,
		// we don't want to add 'prefetch' and 'prefetch-intent' if both are specified
		prefetch && !prefetchIntent ? 'prefetch' : '',
		prefetchIntent ? 'prefetch-intent' : '',
	]
		.filter((option) => Boolean(option) && option.trim() !== '')
		.join(' ');
}
---

<a href={href} target={target} rel={_rel} class:list={classes} {...attrs}>
	<slot />
</a>
